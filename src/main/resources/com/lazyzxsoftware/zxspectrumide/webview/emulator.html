<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>ZX Spectrum IDE</title>
    <style>
        body {
            background-color: #2b2b2b;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #0f0;
            font-family: monospace;
            overflow: hidden;
        }

        #game-container {
            width: 640px;
            height: 480px;
            border: 20px solid #101010;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            image-rendering: pixelated;
            width: 100% !important;
            height: 100% !important;
        }

        .status-msg {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 5px;
            font-size: 12px;
            pointer-events: none;
            z-index: 100;
            display: none;
        }
    </style>

    <script src="js/jsspeccy-core.min.js"></script>
    <script src="js/autoloaders.js"></script>

</head>
<body>

<div id="game-container">
    <div id="speccy"></div>
</div>

<div id="status" class="status-msg">Estado...</div>

<script>
    var emulator = null;

    // =========================================================================
    // üíâ EL INTERCEPTOR (Monkey Patch)
    // =========================================================================
    // Este bloque intercepta la creaci√≥n del procesador Z80 dentro de JSSpeccy
    // para capturar y exponer el objeto 'memory' antes de que quede oculto.
    // Esto es necesario para que el Debugger y el Visor de Memoria funcionen.
    if (window.JSSpeccy && window.JSSpeccy.Z80) {
        var originalZ80 = window.JSSpeccy.Z80;

        window.JSSpeccy.Z80 = function(opts) {
            // 1. Creamos la instancia original
            var z80Instance = originalZ80(opts);

            // 2. Le inyectamos la memoria p√∫blica si est√° disponible en las opciones
            if (opts.memory) {
                z80Instance.memory = opts.memory;
                // console.log("üîì Memoria RAM desbloqueada para acceso externo.");
            }
            return z80Instance;
        };
    } else {
        console.error("‚ùå No se pudo aplicar el parche de memoria (JSSpeccy no cargado).");
    }

    // =========================================================================
    // 1. PUENTE Y ARRANQUE
    // =========================================================================

    function initBridge() {
        if (window.javaApp) {
            // log("Conectado a Java.");
            window.javaApp.requestRomLoad();
        } else {
            setTimeout(initBridge, 200);
        }
    }

    function startEmulatorWithRom(romBase64) {
        try {
            var opts = {
                'autostart': true,
                'scaleFactor': 2,
                'machine': '48',
                'romURL': "data:application/octet-stream;base64," + romBase64
            };

            emulator = JSSpeccy('speccy', opts);

            // Verificaci√≥n para Java
            if (emulator && emulator.getZ80 && emulator.getZ80().memory) {
                if(window.javaApp) window.javaApp.log("‚úÖ Acceso a RAM nativa: OK");
            }

            if(window.javaApp) window.javaApp.onEmulatorReady();

        } catch (e) {
            error("Error arranque: " + e);
        }
    }

    // =========================================================================
    // 2. CARGA DE PROGRAMAS (.TAP)
    // =========================================================================

    function loadProgramFromJava(base64Data, filename) {
        try {
            var binaryString = window.atob(base64Data);
            var len = binaryString.length;
            var bytes = new Uint8Array(len);
            for (var i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            var blob = new Blob([bytes], {type: 'application/octet-stream'});
            var tapeUrl = URL.createObjectURL(blob);

            if (emulator) {
                // Asegurar foco y audio
                window.focus();
                if (emulator.audio && emulator.audio.context && emulator.audio.context.state === 'suspended') {
                    emulator.audio.context.resume();
                }

                // Carga con auto-arranque (autoloaders.js escribir√° LOAD "")
                emulator.loadFromUrl(tapeUrl, {'autoload': true});
            }
        } catch (e) {
            error("Error carga: " + e.message);
        }
    }

    // =========================================================================
    // 3. HERRAMIENTAS DE DEPURACI√ìN (Lectura de Memoria)
    // =========================================================================

    // Funci√≥n segura para leer un byte gracias al interceptor
    function safeReadByte(addr) {
        try {
            if (emulator && emulator.getZ80 && emulator.getZ80().memory) {
                return emulator.getZ80().memory.read(addr & 0xFFFF);
            }
        } catch (e) {}
        return 0;
    }

    // A. Llamado periodicamente para actualizar registros y desensamblador
    function debugTest() {
        var report = { status: "fail" };
        try {
            if (emulator && emulator.getZ80) {
                var z80 = emulator.getZ80();
                report.status = "success";

                // Registros principales
                report.pc = z80.getPC();
                report.sp = z80.getSP();
                report.af = z80.getAF();
                report.bc = z80.getBC();
                report.de = z80.getDE();
                report.hl = z80.getHL();
                report.ix = z80.getIX();
                report.iy = z80.getIY();

                // Registros alternativos
                if(z80.getAF_Alt) report.af_ = z80.getAF_Alt();
                if(z80.getBC_Alt) report.bc_ = z80.getBC_Alt();
                if(z80.getDE_Alt) report.de_ = z80.getDE_Alt();
                if(z80.getHL_Alt) report.hl_ = z80.getHL_Alt();

                // --- CAMBIO: EXTRAER TODA LA MEMORIA (64KB) ---
                // Usamos safeReadByte para evitar errores
                var memDump = [];
                // 65536 bytes = 64KB completo
                for (var i = 0; i < 65536; i++) {
                    memDump.push(safeReadByte(i));
                }
                report.memoryBase64 = window.btoa(String.fromCharCode.apply(null, new Uint8Array(memDump)));
            }
        } catch (e) {}

        sendReport(report);
    }

    // B. Llamado bajo demanda para el Visor de Memoria
    function readMemoryBlock(address, size) {
        try {
            var memDump = [];
            var safeAddr = Math.max(0, Math.min(65535, address));

            for (var i = 0; i < size; i++) {
                memDump.push(safeReadByte(safeAddr + i));
            }

            var b64 = window.btoa(String.fromCharCode.apply(null, new Uint8Array(memDump)));

            if (window.javaApp) {
                window.javaApp.onMemoryRead(safeAddr, b64);
            }
        } catch (e) {
            if(window.javaApp) window.javaApp.log("Error leyendo bloque memoria: " + e);
        }
    }

    // =========================================================================
    // 4. UTILIDADES
    // =========================================================================

    function sendReport(report) {
        if (window.javaApp && report.status === "success") {
            try {
                // Intentamos usar el m√©todo completo (con memoria)
                if (window.javaApp.updateDebugDataFull) {
                    window.javaApp.updateDebugDataFull(
                        report.af, report.bc, report.de, report.hl,
                        report.af_, report.bc_, report.de_, report.hl_,
                        report.ix, report.iy, report.sp, report.pc,
                        report.memoryBase64 || ""
                    );
                } else {
                    // Fallback
                    window.javaApp.updateDebugData(
                        report.af, report.bc, report.de, report.hl,
                        report.af_, report.bc_, report.de_, report.hl_,
                        report.ix, report.iy, report.sp, report.pc
                    );
                }
            } catch(e) {}
        }
    }

    function log(msg) {
        var el = document.getElementById('status');
        el.innerText = msg;
        el.style.display = 'block';
        if(window.javaApp) window.javaApp.log(msg);
        setTimeout(function() { el.style.display = 'none'; }, 3000);
    }

    function error(msg) {
        var el = document.getElementById('status');
        el.innerText = "ERROR: " + msg;
        el.style.display = 'block';
        el.style.color = '#ff5555';
        if(window.javaApp) window.javaApp.log(msg);
    }

    window.onerror = function(msg) { error("JS Global: " + msg); };
    window.onload = function() { setTimeout(initBridge, 100); };

</script>
</body>
</html>